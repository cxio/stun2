# STUN2 -- 新的 NAT 探测设计&流程

> STUN: Session Traversal Utilities for NAT

不同于传统的 STUN（RFC 3489），本库设计了一种新的探测流程来获知NAT内网节点的NAT类型。

这一流程基于*STUN服务节点是一个P2P网络*的环境，服务节点间可相互协作，便捷地提供不同IP的回包，且简化了探测流程。


## NAT 类型

一台连入公网的节点可能是直接的公网主机，也可能是内网中通过NAT网关连入公网的主机。公网主机可接收任意来源的连入请求，但NAT内网主机就有区别了。这与网关的NAT映射方式有关，即NAT类型。

常见的NAT类型有：

1. `Full Cone`：完全圆锥型（`FullC`）。最宽松，网关不对来源地址（IP:Port）作任何限制，可接收任意地址的连入。
2. `Restricted Cone`：受限圆锥型（`RC`）。连入的源IP需与连出时的目标IP相同，但端口不受限制。
3. `Port Restricted Cone`：端口受限圆锥型（`P-RC`）。除了IP要一致外，连入的源Port必须就是连出的目标Port。
4. `Symmetric`：对称型（`Sym`）。内网主机连出的每一个不同目标都会新建一个不同的NAT映射，外部端口无法复用。

另外还有几个不属于NAT但与UDP通讯相关的网域类型：

1. `Open Internet`：开放网络（`Public`）。没有任何约束的公网地址，支持任何连入。
2. `UDP Firewall`：有UDP防火墙。仅主动连出的目标可以与内网节点通讯，即：先有连出，后可连入。
3. `UDP Blocked`：UDP阻塞。完全禁用UDP的通讯。


### 可连通性

- `FullC` 类似于公网 `Public`，但需要连接保活（keep-alive），可以接受任意节点的连入。
- `Sym` 对每个目标的NAT映射都不同，无法复用端口导致无法提供打洞信息，因此基本上不支持打洞。
- `UDP Firewall` 和 `P-RC` 相似，只要先发出了请求，就可以接受目标的回应。`RC` 则更为宽松。

> **提示：**
> 一个仅受限于家庭网关的公网节点可通过 UPnP 映射成为公网节点。



## NAT 类型探测

客户端可以连入STUN服务网络，获取多个服务节点，然后向这些服务节点发送探测请求。


### 准备

节点首先应当确认自己是否位于 UDP 被封禁的网域：从同一个本地端口向2个不同的服务节点尝试 QUIC 连接，如果连接成功，则进入下一步，否则大概率 UDP 被封（`UDP Blocked`），NAT 探测无意义。

> **可靠性：**
> 如果无法创建 QUIC 连接，可再向2台服务器尝试。如果再失败，则基本确认UDP封禁。
> 如果有一台连接成功，则可继续尝试，直到创建第二个连接。
>
> 另外，如果节点已经从 TCP 连接到服务器（确定在线），则可直接请求其 UDP 监听地址并尝试连接。


### 预探测（STUN:Addr, Step.0）

当确认自己的 UDP 链路可用后，客户端向两台不同的服务节点请求获取自身 UDP 地址（`STUN:Addr`）。

然后对比两个地址：

- 不同：为 `Sym` 类型，探测结束。
- 相同：再与本地地址（LocalAddr）对比：
    - 不同（N）：待进一步测试……
    - 相同（Y）：`Open Internet` | `UDP Firewall`，待进一步确认。

> **注：**
> 此时与服务端的连接为 QUIC 安全连接。


### 正式探测（STUN:Cone）

客户端向服务节点请求 NAT 类型探测服务（`STUN:Cone`）。


#### 客户端（Step.1）

客户端的 `STUN:Cone` 请求中包含如下数据：

1. Bas16：会话标识（SN）因子，用于构建 SN。**注**：客户端会暂存发送的 Bas16。
2. Exclist：排除清单，包含在预探测期曾经连接过的目标地址。

> **注：**
> `NewHost` 消息需要一个未曾与客户端连接过的新IP，因此需要排除清单。
> 服务端收到的 `Bas16` 在每次新的请求中都会不同，当次消费即可，无需额外存储。

之后即关闭与服务端的 QUIC 连接，回退到普通 UDP 连接。


#### 会话标识（SN）

会话标识（SN）是一个有着特殊构造规则的标识，用于识别每一次的 NAT 探测消息。

**SN**的构造规则如下（*哈希耦合*）：

```go
// Rnd16: 16字节随机数，
// Rnd16[0]: 首字节的低2位用于标识 NewPort | NewHost。
// flag: 即 NewPort | NewHost 标识位
// 变长随机字节序列：是一段无效的填充字节，用于隐藏 SN 的长度特征。
// SN 的有效长度为 16 + 32 = 48 字节。
Rnd16[0] = Rnd16[0] & 0xFC | flag
SN = Rnd16 + Hash256(Bas16 + Rnd16) + 变长随机字节序列
```

客户端和服务器都遵循同样的 SN 构造规则，且通过该规则核验对方发送的 SN 是否有效。


#### 服务器（Step.2）

服务端获取客户端发来的信息，然后执行如下操作：

- `NewPort`: 用一个新的随机端口向客户端发送消息，数据为即时构造的 SN。
- `NewHost`: 从本机的另一个新IP向客户端发送消息，数据同上。

如果本机没有新的IP可用，则请求另一个服务节点协助执行 `NewHost` 操作，向其提供客户端的信息如下：

- 客户端公网映射地址。
- 客户端提供的会话标识因子（`Bas16`）。

协助配合的服务器执行 `NewHost` 操作，遵循相同的 SN 构造规则。

> **实现：**
> 服务器通过普通的UDP连接发送消息，因此需要实现冗余发送逻辑。
> 每一次发送都应当重新构造 SN，以避免重放攻击。


#### 客户端（Step.3）

客户端读取收到的消息，提取前48字节和其中的 `NewPort` | `NewHost` 标识，根据规则核验 SN 是否有效。

如果核验通过，客户端会即时回应，通知服务端停止冗余发送。回应的消息同样遵循 SN 构造规则，服务端也需要执行核验。

**注意**：服务端验证回应时，需确认不是自己发出的SN，避免攻击者借用它中断自己的发送。

核实是否为自己发送的 SN 仅需针对 SN 中的 Rnd16 段比较即可（无重复），因此即时构造的 SN 中的 Rnd16 需暂存以便核验。

> **实现：**
> 客户端可能通过管道方式（Channel）进行通知和判断。


#### 综合判断（Step.4）

客户端根据 `NewPort` 和 `NewHost` 两个连入的情况，综合判断自身 NAT 类型或所在网域。

**NewPort**:
- 收到 => `RC | FullC`。**注**：`FullC` 在 NewHost 段确认&覆盖。
- 超时 => `P-RC | Sym` => `P-RC`。**注**：`Sym` 已在预探测中确认并排除。

**NewHost**:
- 收到 + 预探测.N => `FullC`。
- 收到 + 预探测.Y => `Open Internet`，即 `Public`。
- 超时 + 预探测.Y => `UDP Firewall` 网域。


### 图示

```
                          +------------------+        NewHost Request
                          |      Serv.1      | ---------------------+
                          +------------------+                      |
                            |           /| |                        |
                            |            | |                        |
                            |          1)| |                        V
+--------+                  |   STUN:Cone| |                   +--------+
| Serv.0 |                  |            | |                   | Serv.2 |
+--------+                  |            | |                   +--------+
    |                       |            | | 2)                     |
    |                    0) |            | | NewPort                | 2)
    | 0)             Addr.1 |            | |                        | NewHost
    | Addr.0                |            | |                        |
    V                       V            | V                        V
+-------------------------------------------------------------------------+
|            LocalAddr                 Received?               Received?  |
|                                          3)                      3)     |
|  [Client]                                                               |
+-------------------------------------------------------------------------+


0)
Addr.0 != Addr.1   --> Sym. END.
Addr.0 == Addr.1/
    Addr.1 == LocalAddr (Y)   --> Open Internet | UDP Firewall
    Addr.1 != LocalAddr (N)   --> (Next Step...)

4)
NewPort: Received?
    Yes   --> RC | FullC
    No    --> P-RC
NewHost: Received?
    Yes & 1.N   --> FullC
    Yes & 1.Y   --> Open Internet (Public)
    No  & 1.Y   --> UDP Firewall
```


### 参考：传统NAT类型发现流程（RFC3489）

```
                        +--------+
                        |  Test  |
                        |   I    |
                        +--------+
                             |
                             |
                             V
                            /\              /\
                         N /  \ Y          /  \ Y             +--------+
          UDP     <-------/Resp\--------->/ IP \------------->|  Test  |
          Blocked         \ ?  /          \Same/              |   II   |
                           \  /            \? /               +--------+
                            \/              \/                    |
                                             | N                  |
                                             |                    V
                                             V                    /\
                                         +--------+  Sym.      N /  \
                                         |  Test  |  UDP    <---/Resp\
                                         |   II   |  Firewall   \ ?  /
                                         +--------+              \  /
                                             |                    \/
                                             V                     |Y
                  /\                         /\                    |
   Symmetric  N  /  \       +--------+   N  /  \                   V
      NAT  <--- / IP \<-----|  Test  |<--- /Resp\               Open
                \Same/      |   I    |     \ ?  /               Internet
                 \? /       +--------+      \  /
                  \/                         \/
                  |                           |Y
                  |                           |
                  |                           V
                  |                           Full
                  |                           Cone
                  V              /\
              +--------+        /  \ Y
              |  Test  |------>/Resp\---->Restricted
              |   III  |       \ ?  /
              +--------+        \  /
                                 \/
                                  |N
                                  |       Port
                                  +------>Restricted
```

文档：https://datatracker.ietf.org/doc/html/rfc3489#section-10.2



## 存活期探测（STUN:Live）

NAT映射有存活期，通讯静默超时后NAT映射会失效，对某些应用来说，这个存活期可能很重要。

客户端与服务器间的通信采用 QUIC + 普通 UDP 链路混合模式，QUIC 用于安全传输，普通 UDP 用于 NAT 映射探测。


### 前提条件

服务端运行一个存活期探测服务 quic.Listen（由一个已知的 net.UDPConn 创建）。

服务端公开信息：服务器地址（`IP:Port`）、自签名证书的 SPKI 指纹（`sha256(SPKI)`）。


### 预探测（Step.0）

创建到服务器的普通 UDP 拨号连接（net.UDPConn），并基于此连接创建一个 QUIC 拨号（quic.Conn）连接，使用服务器 SPKI 指纹验证核实证书。这样就创建了客户端到公网的 NAT 映射。

然后客户端执行如下操作：

1. 向服务器请求自身公网映射地址（`STUN:Addr`）。
2. 检查映射地址与自身本地地址是否相同，从而确认自己是否处于 NAT 之内。

如果客户端处于 NAT 之内，则继续下面的流程，否则结束。


### 客户端（Step.1）

客户端关闭与服务端的 QUIC 连接（quic.Conn），即从 QUIC 安全连接退化到普通 UDP 通讯状态。

> **注：**
> 获取到的端口号（`Port.0`）会被暂存，将在下一步被使用。

使用新的随机端口向同一服务节点拨号，创建一个新的 QUIC 安全连接。


### 客户端（Step.2）

在新的 QUIC 安全连接上，向服务器请求存活期探测（`STUN:Live`）服务。

发送数据为：

1. Bas16：序列号（SN）因子，16随机字节序列。用于序列号生成（规则如前 *哈希耦合*）。
2. Port.0：旧端口。即之前请求创建的NAT映射（旧链路）的端口号。

与此同时，客户端会在旧链路（纯UDP）上发送 PING 包以维持原先的 NAT 映射。

> **注：**
> 旧链路上的 PING 包也是下一次 `STUN:Live` 探测请求的计时起点（重置）。


#### 服务器操作

1. 提取客户端的来源IP，以及传递来的旧端口（`Port.0`），构造客户端原公网映射地址。
2. 在旧链路上向客户端地址发送消息，数据构造规则为*哈希耦合*（见前NAT类型探测部分）。

> **注记：**
> 服务器在旧链路上的回应是一种只写逻辑，无需理会客户端发送的 PING 包。

考虑原生纯UDP链路的不可靠，服务器每收到一个 `STUN:Live` 请求，会发送3个消息包（冗余），每个包相隔 100ms。


### 客户端判断

- 如果在先前的端口（`Port.0`）上收到回应，表示映射没有改变。
- 如果没有收到回应（设计为10秒超时），表示映射已经改变，回应不可达。

注意，客户端应当对收到的序列号进行验证，以确保消息是由服务器发送而来，而非伪造。

> **注：**
> 如果需要，客户端可以向不止一个服务器请求测试，综合评估。


### 探测循环（客户端 <=> 服务器）

在一个周期内，客户端需要多次向服务器请求 `STUN:Live` 探测（见 Step.2），每次请求都会重新开始计时。

如果探测超时（NAT 映射失效），客户端需从**Step.0**开始一个全新的探测流程，即从 *粗测* 到 *精测* 的转换。


#### 粗测

客户端每隔一段时间发起一次 `STUN:Live` 请求，时间间隔为**15秒**增量（即精度）。

初始从 `20s` 开始，然后间隔 `35s`、`50s`、`65s` ...，直到设定的终点（最长间隔）或超时。起始间隔20秒足够让双方干净地退出 QUIC。

> **注：**
> 间隔时间完全由客户端控制，服务器仅在收到 `STUN:Live` 请求后才发送探测包。
> 也即服务器的逻辑极其简单：收到请求，构造目标地址和SN、发送消息。


#### 精测

当粗测超时后，基于粗测中超时失败前得到的有效间隔，启动精测流程。

精测从该有效间隔开始，然后以**3秒**的增量（精度）进行探测，直到设定的终点（最长间隔）或超时。

> **注：**
> 粗测与精测是可以分离的，并不要求在同一服务器上进行。


#### 配置

*起始间隔*、*粗测精度*、*精测精度*、*终点时长*（最大间隔）应可由用户配置，以强化对不同网络的适应性。
